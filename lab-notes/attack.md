# Attack lab 实验解析

## 文件内容

本次实验需要好好看官网的 writeup，里面有很详细的介绍和提示

首先本次实验分为两个部分

- 利用栈溢出注入代码进行攻击
- 利用 gadgets，消除栈不可执行和栈地址随机化的保护实现代码攻击

对于两种攻击方式先进行简单解释：

c语言对于数组的引用没有相应的越界检查，而且局部变量和状态信息（例如保存的寄存器的值，以及函数调用后的下一步执行的指令地址）保存在栈中，所以当数组越界以后，对于原先栈中的保存信息进行写操作时，就会导致代码的执行逻辑收到攻击，发生没有预想的变化。



实验有几个文件：

- hex2raw 将 16 进制的顺序字符转化为 gets() 输入的字符串，实现对于缓冲区的显式写入

- farm.c 可以在这里找到这种所需要的 gadgets
- ctarget 第一部分实验的可执行文件
- rtarget 第二部分实验的可执行文件

## 实验部分一

### phase1

首先了解到 ctarget 会调用 test 方法，在 test 方法中调用 getBuf，查看 getBuf 的汇编可以知道：

对于栈指针的下移 40 个字节，只需要输入 48 个字节，后 8 个字节就是函数调用后，下一步要执行的指令的地址，所以将 touch1 函数的指令首地址写入，那么当 getBuf 调用完了以后，程序会去执行 touch1 方法， 实验完成

所以栈中应该呈现的数据形式：



### phase2

这里对于 phase1 来说，只是多了一个穿参数的操作，我们理想的调用情况应该是，字符输入完以后，函数跳转至执行 参数传入，然后再调用 touch2，由于栈是可执行的，所以我们可以将 getbuf执行后的返回地址 重写成栈的地址，然后通过栈中我们注入的编码好的指令进行传参，最后跳转至 touch2.

注意到 touch2 中要求传入的参数的值为 cookie，切下一步应该是调用 touch2 所以应该要执行的指令为：



转化为二进制：



可以将传参的指令写到栈顶，然后在 40 个字节后面重写写入栈顶地址，这样就可以达到整个调用链的状态

所以可以将输入的字符串整理为：



### phase3

本题和 phase3 差不多，只不过将传入的参数换成了一个字符串，也就是一个 char * 指针，同时可以调试的时候可以看到 40 个字节其实不太安全，后面会覆盖掉传入的参数，那么可以将 字符串的写入换到 test 返回地址后面，其他情况和 phase2 类似，所以答案可以如下所示：





## 实验部分二

